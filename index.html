<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Rotating Screen</title>
    <style>
      :root {
        color-scheme: dark;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        background: #000;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color: #fff;
      }

      body {
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .screen {
        position: relative;
        width: 100vw;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
      }

      .screen__image {
        width: 100vw;
        height: 100vh;
        object-fit: cover;
        object-position: center;
        background: #000;
      }

      .status-bar {
        position: absolute;
        left: 0;
        bottom: 0;
        width: 100%;
        height: 6px;
        background: rgba(255, 255, 255, 0.15);
        overflow: hidden;
      }

      .status-bar__fill {
        width: 100%;
        height: 100%;
        background: #18a5a7;
        transform-origin: left;
        transform: scaleX(0);
      }

      @keyframes status-bar-progress {
        from {
          transform: scaleX(0);
        }
        to {
          transform: scaleX(1);
        }
      }
    </style>
  </head>
  <body>
    <main class="screen">
      <img
        id="rotating-image"
        class="screen__image"
        src=""
        alt="Rotating scheduled content"
      />
      <div class="status-bar">
        <div id="status-bar-fill" class="status-bar__fill"></div>
      </div>
    </main>
    <script>
      (function () {
        const DISPLAY_DURATION_MS = 30_000;
        const PROGRAM_IMAGE = "images/program.png";
        const IMAGES_DIRECTORY = "images/";
        const IMAGE_EXTENSION_PATTERN = /\.(png|jpe?g|gif|webp|bmp|svg)$/i;
        const statusFillEl = document.getElementById("status-bar-fill");
        const imageEl = document.getElementById("rotating-image");

        let rotationTimer = null;
        let contentImages = [];
        let contentIndex = 0;
        let shouldShowProgramNext = false;

        function animateStatusBar() {
          statusFillEl.style.animation = "none";
          // Force reflow so the animation restarts cleanly each cycle.
          void statusFillEl.offsetWidth;
          statusFillEl.style.animation = `status-bar-progress ${DISPLAY_DURATION_MS}ms linear forwards`;
        }

        function updateImage() {
          const nextSrc = getNextImageSrc();
          if (!nextSrc) {
            return;
          }

          imageEl.src = nextSrc;
          animateStatusBar();
        }

        function startRotation() {
          updateImage();

          if (rotationTimer) {
            clearInterval(rotationTimer);
          }

          rotationTimer = setInterval(updateImage, DISPLAY_DURATION_MS);
        }

        function getNextImageSrc() {
          if (!contentImages.length) {
            return PROGRAM_IMAGE;
          }

          if (shouldShowProgramNext) {
            shouldShowProgramNext = false;
            return PROGRAM_IMAGE;
          }

          const src = contentImages[contentIndex];
          contentIndex = (contentIndex + 1) % contentImages.length;
          shouldShowProgramNext = true;
          return src;
        }

        function sanitizeImageEntries(data) {
          const entries = Array.isArray(data)
            ? data
            : Array.isArray(data?.images)
            ? data.images
            : [];

          const cleaned = entries
            .map((entry) => String(entry))
            .map((entry) => entry.replace(/^\.?\/?images\//i, "").trim())
            .filter(
              (entry) =>
                entry.length > 0 &&
                entry.toLowerCase() !== "program.png" &&
                IMAGE_EXTENSION_PATTERN.test(entry)
            );

          const uniqueSorted = [...new Set(cleaned)].sort((a, b) =>
            a.localeCompare(b, undefined, { numeric: true, sensitivity: "base" })
          );

          return uniqueSorted.map((entry) => `${IMAGES_DIRECTORY}${entry}`);
        }

        async function discoverContentImages() {
          const directoryEntries = await fetchDirectoryListing();
          if (directoryEntries.length) {
            return directoryEntries;
          }

          const manifestEntries = getManifestFromWindow();
          if (manifestEntries.length) {
            return manifestEntries;
          }

          console.warn(
            "No content images found; falling back to program image only."
          );
          return [];
        }

        function getManifestFromWindow() {
          if (
            typeof window === "undefined" ||
            typeof window.__ROTATING_SCREEN_MANIFEST__ === "undefined"
          ) {
            return [];
          }

          return sanitizeImageEntries(window.__ROTATING_SCREEN_MANIFEST__);
        }

        async function fetchDirectoryListing() {
          try {
            const response = await fetch(IMAGES_DIRECTORY, { cache: "no-store" });
            if (!response.ok) {
              throw new Error(
                `Directory listing request failed with status ${response.status}`
              );
            }

            const markup = await response.text();
            return parseDirectoryListing(markup);
          } catch (error) {
            console.error(
              "Unable to load images via directory listing. Check that your server exposes directory indexes.",
              error
            );
            return [];
          }
        }

        function parseDirectoryListing(markup) {
          const parser = new DOMParser();
          let filenames = [];

          try {
            const doc = parser.parseFromString(markup, "text/html");
            filenames = Array.from(doc.querySelectorAll("a[href]"))
              .map((anchor) => anchor.getAttribute("href") || "")
              .map(normalizeHrefToFileName)
              .filter(Boolean);
          } catch (error) {
            filenames = [];
          }

          if (!filenames.length) {
            filenames = markup
              .split(/[\s"'=<>]+/)
              .map(normalizeHrefToFileName)
              .filter(Boolean);
          }

          return sanitizeImageEntries(filenames);
        }

        function normalizeHrefToFileName(value) {
          if (!value || value === "." || value === "..") {
            return "";
          }

          const sanitized = (value || "").split("#")[0].split("?")[0];
          const safeValue = safeDecodeURIComponent(sanitized).trim();

          if (!safeValue || safeValue.endsWith("/")) {
            return "";
          }

          const parts = safeValue.replace(/\\/g, "/").split("/");
          return parts[parts.length - 1] || "";
        }

        function safeDecodeURIComponent(input) {
          try {
            return decodeURIComponent(input);
          } catch (error) {
            return input;
          }
        }

        async function loadManifest() {
          contentImages = await discoverContentImages();
          contentIndex = 0;
          shouldShowProgramNext = false;

          startRotation();
        }

        document.addEventListener("visibilitychange", () => {
          if (!document.hidden) {
            animateStatusBar();
          }
        });

        loadManifest();
      })();
    </script>
  </body>
</html>
